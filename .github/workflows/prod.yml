name: Production Deployment

on:
  pull_request:
    branches:
      - prod
    types: [opened, synchronize]
  push:
    branches:
      - prod

jobs:
  # Run on PR to main
  pre-production-checks:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv

      - name: Install dependencies
        run: |
          uv pip install -r requirements.txt --system
          uv pip install -r requirements-dev.txt --system

      - name: Run linting with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml

      - name: SonarCloud Analysis
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Build Docker Image for Security Scan
        run: docker build -t temp-image:latest .

      - name: Test Docker Image
        run: |
          docker-compose run test

      - name: Run Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'temp-image:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: 1

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Run on merge to main
  production-deployment:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv

      - name: Install dependencies
        run: |
          uv pip install -r requirements.txt --system
          uv pip install -r requirements-dev.txt --system

      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html

      - name: Create semantic version
        id: version
        run: |
          # Calculate next version based on conventional commits
          # This is a simplified version - consider using semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")

          # Check commit messages for version bump type
          if git log --oneline ${LATEST_TAG}..HEAD | grep -E "^[^:]+!:" > /dev/null; then
            # Breaking change
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$1 = $1 + 1; $2 = 0; $3 = 0} 1' OFS=.)
          elif git log --oneline ${LATEST_TAG}..HEAD | grep -E "^feat:" > /dev/null; then
            # New feature
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$2 = $2 + 1; $3 = 0} 1' OFS=.)
          else
            # Patch
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$3 = $3 + 1} 1' OFS=.)
          fi

          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "Creating version: ${NEW_VERSION}"

      - name: Create Git Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a ${{ steps.version.outputs.version }} -m "Release ${{ steps.version.outputs.version }}"
          git push origin ${{ steps.version.outputs.version }}

      - name: Build Production Image
        run: |
          docker build -t ${{ secrets.REGISTRY_URL }}/app:${{ steps.version.outputs.version }} .
          docker build -t ${{ secrets.REGISTRY_URL }}/app:prod-latest .

      - name: Test Docker Image
        run: |
          docker-compose run test

      - name: Login to Registry
        run: echo ${{ secrets.REGISTRY_PASSWORD }} | docker login ${{ secrets.REGISTRY_URL }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin

      - name: Push Production Image
        run: |
          docker push ${{ secrets.REGISTRY_URL }}/app:${{ steps.version.outputs.version }}
          docker push ${{ secrets.REGISTRY_URL }}/app:prod-latest

      - name: Deploy to Production
        run: |
          echo "Deploying version ${{ steps.version.outputs.version }} to production..."
          # kubectl set image deployment/myapp container=${{ secrets.REGISTRY_URL }}/app:${{ steps.version.outputs.version }}

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
