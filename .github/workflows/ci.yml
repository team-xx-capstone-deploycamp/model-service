name: Production Deployment

on:
  pull_request:
    branches:
      - prod
    types: [opened, synchronize]
  push:
    branches:
      - prod
    paths:
      - 'data/**'
      - 'src/**'
      - 'web/**'
      - 'Dockerfile'
      - 'requirements.txt'
      - 'requirements-dev.txt'
      - 'docker-compose.yml'

jobs:
  # Run on PR to main
  pre-production-checks:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv

      - name: Install dependencies
        run: |
          uv pip install -r docker/luigi/requirements.txt --system
          uv pip install -r docker/wrapper/requirements.txt --system
          uv pip install -r requirements-dev.txt --system

      - name: Run linting with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml

      - name: SonarCloud Analysis
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Build Docker Image for Security Scan
        run: docker build -t temp-image:latest .

      - name: Test Docker Image
        run: |
          docker-compose run test

      - name: Run Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'temp-image:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: 1

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Check for DVC file changes
  check-dvc-changes:
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod'
    runs-on: ubuntu-latest
    outputs:
      dvc_changed: ${{ steps.check-dvc.outputs.dvc_changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for DVC file changes
        id: check-dvc
        run: |
          git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "data/.*\.dvc$" && echo "dvc_changed=true" >> $GITHUB_OUTPUT || echo "dvc_changed=false" >> $GITHUB_OUTPUT
          echo "DVC files changed: ${{ steps.check-dvc.outputs.dvc_changed }}"

  # Run Luigi task if DVC files changed
  run-luigi-task:
    needs: check-dvc-changes
    if: needs.check-dvc-changes.outputs.dvc_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv

      - name: Install dependencies
        run: |
          uv pip install -r docker/luigi/requirements.txt --system
          uv pip install -r docker/wrapper/requirements.txt --system
          uv pip install -r requirements-dev.txt --system

      - name: Run Luigi Pipeline
        run: |
          python src/run_pipeline.py

  # Run on merge to prod
  production-deployment:
    needs: [check-dvc-changes]
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod'
    runs-on: ubuntu-latest
    environment: production
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install uv
        run: |
          python -m pip install --upgrade pip
          pip install uv

      - name: Install dependencies
        run: |
          uv pip install -r docker/luigi/requirements.txt --system
          uv pip install -r docker/wrapper/requirements.txt --system
          uv pip install -r requirements-dev.txt --system

      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html

      - name: Create semantic version
        id: version
        run: |
          # Calculate next version based on conventional commits
          # This is a simplified version - consider using semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")

          # Check commit messages for version bump type
          if git log --oneline ${LATEST_TAG}..HEAD | grep -E "^[^:]+!:" > /dev/null; then
            # Breaking change
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$1 = $1 + 1; $2 = 0; $3 = 0} 1' OFS=.)
          elif git log --oneline ${LATEST_TAG}..HEAD | grep -E "^feat:" > /dev/null; then
            # New feature
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$2 = $2 + 1; $3 = 0} 1' OFS=.)
          else
            # Patch
            NEW_VERSION=$(echo $LATEST_TAG | awk -F. '{$3 = $3 + 1} 1' OFS=.)
          fi

          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "Creating version: ${NEW_VERSION}"

      - name: Create Git Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a ${{ steps.version.outputs.version }} -m "Release ${{ steps.version.outputs.version }}"
          git push origin ${{ steps.version.outputs.version }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}},value=${{ steps.version.outputs.version }}
            type=raw,value=prod-latest

      - name: Build Production Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Test Docker Image
        run: |
          docker pull ghcr.io/${{ github.repository }}:prod-latest
          docker tag ghcr.io/${{ github.repository }}:prod-latest app:prod-latest
          docker-compose run app python -m pytest

      - name: Deploy to Production
        run: |
          echo "Deploying version ${{ steps.version.outputs.version }} to production..."
          # kubectl set image deployment/myapp container=${{ secrets.REGISTRY_URL }}/app:${{ steps.version.outputs.version }}

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
